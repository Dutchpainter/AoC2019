using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace Dag_12
{
    class Program
    {
        static void Main(string[] args)
        {
            var moonPositions = File
                 .ReadAllLines("Inputtest.txt")
                 .Where(s => !string.IsNullOrWhiteSpace(s))
                 .ToList();

            var moons = new Moons(moonPositions);
            moons.PrintMoons();
            moons.StepThroughTime(-1);
            moons.PrintMoons();
            Console.WriteLine();
            Console.WriteLine("De opdracht is afgerond.");
        }
    }
    public class Moons
    {
        int Time { get; set; }
        public List<string> ListOfNames { get; }
        public List<List<int>> Positions { get; set; }
        public List<List<int>> Velocities { get; set; }
        public List<string> StartPositions { get; }
        public int NumberOfMoons { get; }
        public Moons(List<string> positions)
        {
            Time = 0;
            NumberOfMoons = 4;
            StartPositions = new List<string>(positions);
            ListOfNames = new List<string> {"Io", "Europe", "Ganymede", "Callisto" };
            Velocities = new List<List<int>>();
            InitVelocity();
            Positions = new List<List<int>>(MakeValues(StartPositions));
        }
        bool InitVelocity()
        {
            for (var i = 0; i < NumberOfMoons; i++)
            {
                var velocity = new List<int>();
                for (var j = 0; j < 3; j++)
                {
                    velocity.Add(0);
                }
                Velocities.Add(velocity);
            }
            return true;
        }
        bool UpdateSpeed()
        {
            for (var i = 0; i < NumberOfMoons; i++)
            {
                for (var j = 0; j < 3; j++)
                {
                    Positions[i][j] += Velocities[i][j];
                }
            }
            return true;
        }
        bool ApplyGravity()
        {
            var valAllGravity = new List<List<int>>();
            for (var i = 0; i < NumberOfMoons; i++) // de maan
            {
                var gravityX = 0;
                var gravityY = 0;
                var gravityZ = 0;
                for (var j = 0; j< NumberOfMoons - 1; j++)// x of y of z
                {
                    gravityX += (Positions[(i + j + 1) % 4][0] == Positions[i][0]) ? 0 : (Positions[(i + j + 1) % 4][0] > Positions[i][0]) ? 1 : -1;
                    gravityY += (Positions[(i + j + 1) % 4][1] == Positions[i][1]) ? 0 : (Positions[(i + j + 1) % 4][1] > Positions[i][1]) ? 1 : -1;
                    gravityZ += (Positions[(i + j + 1) % 4][2] == Positions[i][2]) ? 0 : (Positions[(i + j + 1) % 4][2] > Positions[i][2]) ? 1 : -1;
                }
                var valGravity = new List<int>{ gravityX, gravityY, gravityZ};
                valAllGravity.Add(valGravity);
            }
            for(var i = 0; i< NumberOfMoons; i++)
            {
                for (var j = 0; j<3; j++)
                {
                    Velocities[i][j] += valAllGravity[i][j];
                }
            }
            return true;
        }
        public List<List<int>>  MakeValues(List<string> inputStrings)
        {
            var listOfAllValues = new List<List<int>>();
            for (var i = 0; i< inputStrings.Count; i++)
            {
                var inputValues = inputStrings[i].Split(',');
                var listOfValues = new List<int>();
                listOfValues.Add(int.Parse(inputValues[0].Substring(3)));
                listOfValues.Add(int.Parse(inputValues[1].Substring(3)));
                listOfValues.Add(int.Parse(inputValues[2].Substring(3, inputValues[2].Length - 4)));
                listOfAllValues.Add(listOfValues);
            }
            return listOfAllValues;
        }
        public List<string> MakeStrings(List<List<int>> values)
        {
            var newValues = new List<string> (); 
            for (var i = 0; i < values.Count; i++)
            {
                newValues.Add( "<x=" + values[i][0].ToString()
                + ", y=" + values[i][1].ToString()
                + ", z=" + values[i][2].ToString() + ">");
            }
            return newValues;
        }
        bool CheckRepeat()
        {
            bool isIdentical = true;
            var stringPositions = MakeStrings(Positions);
            for (var i=0; i < ListOfNames.Count; i++)
            {
                if (stringPositions[i] != StartPositions[i]) isIdentical = false;
            }
            return isIdentical;
        }
        public int CalculateTotalEnergy()
        {
            var TotalEnergy = 0;
            for (var i = 0; i < NumberOfMoons; i++)
            {
                var potentialEnergy = 0;
                var kineticEnergy = 0;
                for (var j = 0; j < 3; j++)
                {
                    potentialEnergy += Math.Abs(Positions[i][j]);
                    kineticEnergy += Math.Abs(Velocities[i][j]);  
                }
                TotalEnergy += potentialEnergy * kineticEnergy;
            }
            return TotalEnergy;
        }
        public bool PrintMoons()
        {
            Console.WriteLine($"After {Time} steps ");
            var energy = CalculateTotalEnergy();
            var speeds = MakeStrings(Velocities);
            var pos = MakeStrings(Positions);
            for (var i = 0; i < NumberOfMoons; i++)
            {
                Console.WriteLine($"{pos[i]} {speeds[i]}");
            }
            Console.WriteLine($"Total Energy {energy}");
            return true;
        }
        public int StepThroughTime(int times = -1)
        {
            var count = 0;
            while( Time < times  || times == -1)
            {
                ApplyGravity();
                UpdateSpeed();
                Time++;
                if (CheckRepeat()) return Time + 1;
                count++;
                if(count / 1000000 == 1)
                {
                    Console.WriteLine(Time);
                    count = 0;
                }
            }
            return Time;
        }
       
    }
}
